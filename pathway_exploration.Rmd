
---
title: "R Notebook"
output: html_notebook
---

```{r}
# biocLite("KEGGgraph")
# biocLite("UniProt.ws")
library(KEGGgraph)
library(UniProt.ws)
```

KEGGgraph is probably great for using the topological info from pathways, but for now I just want genelists.

```{r}
# biocLite("org.Hs.eg.db")
library(org.Hs.eg.db)
kegg <- org.Hs.egPATH2EG
mapped <- mappedkeys(kegg)
kegg2 <- as.list(kegg[mapped])
```
Oh joy... I need to convert identifiers. =D

```{r}
uniprots <- Rkeys(org.Hs.egUNIPROT)
# genes_BRCA_mRNA <- colnames(BRCA_mRNA)
# genes_BRCA_mRNA[1:4]
# genes <- UniProt.ws(genes_BRCA_mRNA)
select(org.Hs.eg.db, uniprots[1:4], "ENTREZID", "UNIPROT")
```
```{r}
# biocLite("GenomicFeatures")
library(GenomicFeatures)
# biocLite("mygene")
library(mygene)
```
```{r}
## Bimap interface:
x <- org.Hs.egGENENAME
# Get the gene names that are mapped to an entrez gene identifier
mapped_genes <- mappedkeys(x)
# Convert to a list
xx <- as.list(x[mapped_genes])
```

```{r}
gene_lookup <- cbind(org.Hs.eg.db, getGene(org.Hs.eg.db)$name)
```
```{r}
# biocLite("biomaRt")
library(biomaRt)
```

```{r}
ensembl <- useMart("ensembl",dataset="hsapiens_gene_ensembl")
 
#create a filter for all assembled human chromosomes
my_chr <- c(1:22, 'M', 'X', 'Y')
 
#listAttributes shows all attributes
attributes <- listAttributes(ensembl)
 
#find entrez attribute name
grep(pattern="entrez", x=attributes$description, ignore.case=T)
#[1] 62
attributes[62,]
# entrezgene

grep(pattern="hgnc symbol", x=attributes$description, ignore.case=T)
attributes[71,]
# hgnc_symbol
```
```{r}
entrez_hgnc <- getBM(attributes = c('entrezgene', "hgnc_symbol"),
                        filters = 'chromosome_name',
                        values = my_chr,
                        mart = ensembl
                        )
entrez_hgnc <- entrez_hgnc[complete.cases(entrez_hgnc),]
entrez_hgnc <- entrez_hgnc[entrez_hgnc$entrezgene != "" & entrez_hgnc$hgnc_symbol != "",]
dupli_hgnc <- duplicated(entrez_hgnc$hgnc_symbol)
entrez_hgnc <- entrez_hgnc[!dupli_hgnc,]

rownames(entrez_hgnc) <- entrez_hgnc$hgnc_symbol

```
The test:
```{r}
entrez_BRCA_mRNA <- entrez_hgnc[rownames(BRCA_mRNA), "entrezgene"]
names(entrez_BRCA_mRNA) <- rownames(BRCA_mRNA)
pw1_genes <- entrez_BRCA_mRNA[as.numeric(kegg2[[1]])]
# pathway1_BRCA_mRNA <- apply(BRCA_mRNA[names(pw1_genes),], 1, mean)
```

```{r}
PathwaysMrna <- function(i){
  ind <- rownames(BRCA_mRNA) %in% names(entrez_BRCA_mRNA[as.numeric(kegg2[[i]])])
  if(sum(ind) == 0){return(NULL)}
  if(sum(ind) == 1){return(BRCA_mRNA[ind,])}
  return(apply(BRCA_mRNA[ind,], 2, mean))
}
vPathwaysMrna <- Vectorize(PathwaysMrna)
```
Rewrite the above function to return just one pathway, and cbind the results
```{r}
test4pathways <- vPathwaysMrna(1:4)
colnames(test4pathways) <- names(kegg2[1:4])
```

A few thoughts:

* If I'm collapsing the data on pathways, what is the effect of some data sources having data for a particular gene in a particular pathway and others not having data for that particular gene? Would it be best to remove that gene altogether or not?

13-03-2017
```{r}
# objname <- sprintf("entrez_%s_mRNA", d)
# print(objname)
# data <- get(sprintf("%s_mRNA", d))
# assign(objname, entrez_hgnc[rownames(data), "entrezgene"])
# obj <- get(objname)
# names(obj) <- rownames(data)
# all these objects are identical!
entrez_mRNA <- entrez_hgnc[rownames(BRCA_mRNA), "entrezgene"]
names(entrez_mRNA) <- rownames(BRCA_mRNA)
```

```{r}
# BRCA_mRNA <- BRCA_mRNA_corrected
# OV_mRNA <- OV_mRNA_corrected
save(BRCA_mRNA, file = "/home/abidata/Joanna/BRCA/mRNA/BRCA_mRNA.rda")
save(BRCA_mRNA_patients, file = "/home/abidata/Joanna/BRCA/mRNA/BRCA_mRNA_patients.rda")
save(OV_mRNA, file = "/home/abidata/Joanna/OV/mRNA/OV_mRNA.rda")
save(OV_mRNA_patients, file = "/home/abidata/Joanna/OV/mRNA/OV _mRNA_patients.rda")
save(GBM_mRNA, file = "/home/abidata/Joanna/GBM/mRNA/GBM_mRNA.rda")
save(GBM_mRNA_patients, file = "/home/abidata/Joanna/GBM/mRNA/GBM _mRNA_patients.rda")
```


```{r}
for(d in names(diseases)){
  # objname <- sprintf("%s_mRNA_pathways", d)
  # print(objname)
  print(d)
  obj <- PathwaysMrna(1:229, d)
  # assign(objname, PathwaysMrna(1:229, d))
  colnames(obj) <- names(kegg2)
  assign(sprintf("%s_mRNA_pathways", d), obj)
}
```

05-04-2017

The function for average per pathway was adjusted to work on all omics types instead of only mRNA:

```{r}
for(d in names(diseases)){
  print(d)
  for(o in omics[5]){
    print(o)
    if(exists(sprintf("%s_%s", d, o))){
      obj <- AveragePerPathway(1:229, d, o)
      # colnames(obj) <- names(kegg2)
      assign(sprintf("%s_%s_avg", d, o), t(obj))
    }
  }
}
```

It is not a good idea to use the average operator for CNV data, since these can have negative and positive values. Read more about this, but it might be a good idea to use the fraction of changed genes in a pathway as pathway activity. Another approach might be to undo the -2 transformation to get to to the original data where 0 doesn't mean a copy number of 2 but an actual copy number of 0.

Try this:

```{r}
for(d in names(diseases)){
  objname <- sprintf("%s_CNV", d)
  obj <- get(objname)
  assign(objname, obj+2)
}
```

Well, that was easy. But of course, transforming the data like this does not change the distribution. Now up- and down-regulation will still be canceled out. So back to the idea for fraction of changed or unchanged genes per pathway. If none of the genes in a certain pathway have a changed copy number, I want the ratio to be zero. So, if all the genes have a CNV of zero, I want the result to be zero. If 1/10th of the genes has a CNV of -0.5 and the rest is unchanged, I want the result to be 0.05. If 1/10th of the genes has a CNV of +0.5, I also want the result to be 0.05.

```{r}
# RUCN is Ratio of Unchanged Copy Number
RUCN <- function(data, patients, mseq = FALSE){
  genes <- entrez_hgnc[rownames(data), "entrezgene"]
  res <- do.call(rbind, 
                 lapply(
                   kegg2,
                   function(pw_genes){
                     ind <- genes %in% pw_genes
                     ind2 <- data[ind,]
                     if(sum(ind) == 0){return(NULL)}
                     
                     pw_ratio <- 
                     # pw2 <- predict(prcomp(t(ind2)), newdata = t(ind2))[,1]
                     names(pw_ratio) <- NULL
                     return(pw_ratio)
                   }
                 )
  )
  colnames(res) <- rownames(patients)
  return(res)
}
```

